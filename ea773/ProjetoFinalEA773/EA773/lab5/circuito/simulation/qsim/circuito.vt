// Copyright (C) 1991-2013 Altera Corporation
// Your use of Altera Corporation's design tools, logic functions 
// and other software and tools, and its AMPP partner logic 
// functions, and any output files from any of the foregoing 
// (including device programming or simulation files), and any 
// associated documentation or information are expressly subject 
// to the terms and conditions of the Altera Program License 
// Subscription Agreement, Altera MegaCore Function License 
// Agreement, or other applicable license agreement, including, 
// without limitation, that your use is for the sole purpose of 
// programming logic devices manufactured by Altera and sold by 
// Altera or its authorized distributors.  Please refer to the 
// applicable agreement for further details.

// *****************************************************************************
// This file contains a Verilog test bench with test vectors .The test vectors  
// are exported from a vector file in the Quartus Waveform Editor and apply to  
// the top level entity of the current Quartus project .The user can use this   
// testbench to simulate his design using a third-party simulation tool .       
// *****************************************************************************
// Generated on "05/24/2018 21:48:51"
                                                                        
// Verilog Self-Checking Test Bench (with test vectors) for design :    circuito
// 
// Simulation tool : 3rd Party
// 

`timescale 1 ps/ 1 ps
module circuito_vlg_sample_tst(
	clock,
	K0,
	K1,
	K2,
	RESET,
	SEL0,
	SEL1,
	SEL2,
	sampler_tx
);
input  clock;
input  K0;
input  K1;
input  K2;
input  RESET;
input  SEL0;
input  SEL1;
input  SEL2;
output sampler_tx;

reg sample;
time current_time;
always @(clock or K0 or K1 or K2 or RESET or SEL0 or SEL1 or SEL2)
                                                                                
begin                                                 
 if ($realtime > 0)                                   
 begin                                                
	if ($realtime == 0 || $realtime != current_time)  
	begin									          
		if (sample === 1'bx)                          
			sample = 0;                               
		else                                          
			sample = ~sample;                         
	end										          
	current_time = $realtime;					      
 end                                                  
end                                                   

assign sampler_tx = sample;
endmodule

module circuito_vlg_check_tst (
	data_out,
	end_port,
	flipA,
	flipB,
	LOAD_CP,
	progm0,
	progm1,
	progm2,
	sampler_rx
);
input [2:0] data_out;
input [2:0] end_port;
input  flipA;
input  flipB;
input  LOAD_CP;
input  progm0;
input  progm1;
input  progm2;
input sampler_rx;

reg [2:0] data_out_expected;
reg [2:0] end_port_expected;
reg  flipA_expected;
reg  flipB_expected;
reg  LOAD_CP_expected;
reg  progm0_expected;
reg  progm1_expected;
reg  progm2_expected;

reg [2:0] data_out_prev;
reg [2:0] end_port_prev;
reg  flipA_prev;
reg  flipB_prev;
reg  LOAD_CP_prev;
reg  progm0_prev;
reg  progm1_prev;
reg  progm2_prev;

reg [2:0] data_out_expected_prev;
reg [2:0] end_port_expected_prev;
reg  flipA_expected_prev;
reg  LOAD_CP_expected_prev;
reg  progm0_expected_prev;
reg  progm1_expected_prev;
reg  progm2_expected_prev;

reg [2:0] last_data_out_exp;
reg [2:0] last_end_port_exp;
reg  last_flipA_exp;
reg  last_LOAD_CP_exp;
reg  last_progm0_exp;
reg  last_progm1_exp;
reg  last_progm2_exp;

reg trigger;

integer i;
integer nummismatches;

reg [1:8] on_first_change ;


initial
begin
trigger = 0;
i = 0;
nummismatches = 0;
on_first_change = 8'b1;
end

// update real /o prevs

always @(trigger)
begin
	data_out_prev = data_out;
	end_port_prev = end_port;
	flipA_prev = flipA;
	flipB_prev = flipB;
	LOAD_CP_prev = LOAD_CP;
	progm0_prev = progm0;
	progm1_prev = progm1;
	progm2_prev = progm2;
end

// update expected /o prevs

always @(trigger)
begin
	data_out_expected_prev = data_out_expected;
	end_port_expected_prev = end_port_expected;
	flipA_expected_prev = flipA_expected;
	LOAD_CP_expected_prev = LOAD_CP_expected;
	progm0_expected_prev = progm0_expected;
	progm1_expected_prev = progm1_expected;
	progm2_expected_prev = progm2_expected;
end



// expected data_out[2]
initial
begin
	data_out_expected[2] = 1'bX;
end 

// expected data_out[1]
initial
begin
	data_out_expected[1] = 1'bX;
end 

// expected data_out[0]
initial
begin
	data_out_expected[0] = 1'bX;
end 

// expected end_port[2]
initial
begin
	end_port_expected[2] = 1'bX;
end 

// expected end_port[1]
initial
begin
	end_port_expected[1] = 1'bX;
end 

// expected end_port[0]
initial
begin
	end_port_expected[0] = 1'bX;
end 

// expected flipA
initial
begin
	flipA_expected = 1'bX;
end 

// expected LOAD_CP
initial
begin
	LOAD_CP_expected = 1'bX;
end 

// expected progm2
initial
begin
	progm2_expected = 1'bX;
end 

// expected progm1
initial
begin
	progm1_expected = 1'bX;
end 

// expected progm0
initial
begin
	progm0_expected = 1'bX;
end 
// generate trigger
always @(data_out_expected or data_out or end_port_expected or end_port or flipA_expected or flipA or flipB_expected or flipB or LOAD_CP_expected or LOAD_CP or progm0_expected or progm0 or progm1_expected or progm1 or progm2_expected or progm2)
begin
	trigger <= ~trigger;
end

always @(posedge sampler_rx or negedge sampler_rx)
begin
`ifdef debug_tbench
	$display("Scanning pattern %d @time = %t",i,$realtime );
	i = i + 1;
	$display("| expected data_out = %b | expected end_port = %b | expected flipA = %b | expected flipB = %b | expected LOAD_CP = %b | expected progm0 = %b | expected progm1 = %b | expected progm2 = %b | ",data_out_expected_prev,end_port_expected_prev,flipA_expected_prev,flipB_expected_prev,LOAD_CP_expected_prev,progm0_expected_prev,progm1_expected_prev,progm2_expected_prev);
	$display("| real data_out = %b | real end_port = %b | real flipA = %b | real flipB = %b | real LOAD_CP = %b | real progm0 = %b | real progm1 = %b | real progm2 = %b | ",data_out_prev,end_port_prev,flipA_prev,flipB_prev,LOAD_CP_prev,progm0_prev,progm1_prev,progm2_prev);
`endif
	if (
		( data_out_expected_prev[0] !== 1'bx ) && ( data_out_prev[0] !== data_out_expected_prev[0] )
		&& ((data_out_expected_prev[0] !== last_data_out_exp[0]) ||
			on_first_change[1])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port data_out[0] :: @time = %t",  $realtime);
		$display ("     Expected value = %b", data_out_expected_prev);
		$display ("     Real value = %b", data_out_prev);
		nummismatches = nummismatches + 1;
		on_first_change[1] = 1'b0;
		last_data_out_exp[0] = data_out_expected_prev[0];
	end
	if (
		( data_out_expected_prev[1] !== 1'bx ) && ( data_out_prev[1] !== data_out_expected_prev[1] )
		&& ((data_out_expected_prev[1] !== last_data_out_exp[1]) ||
			on_first_change[1])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port data_out[1] :: @time = %t",  $realtime);
		$display ("     Expected value = %b", data_out_expected_prev);
		$display ("     Real value = %b", data_out_prev);
		nummismatches = nummismatches + 1;
		on_first_change[1] = 1'b0;
		last_data_out_exp[1] = data_out_expected_prev[1];
	end
	if (
		( data_out_expected_prev[2] !== 1'bx ) && ( data_out_prev[2] !== data_out_expected_prev[2] )
		&& ((data_out_expected_prev[2] !== last_data_out_exp[2]) ||
			on_first_change[1])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port data_out[2] :: @time = %t",  $realtime);
		$display ("     Expected value = %b", data_out_expected_prev);
		$display ("     Real value = %b", data_out_prev);
		nummismatches = nummismatches + 1;
		on_first_change[1] = 1'b0;
		last_data_out_exp[2] = data_out_expected_prev[2];
	end
	if (
		( end_port_expected_prev[0] !== 1'bx ) && ( end_port_prev[0] !== end_port_expected_prev[0] )
		&& ((end_port_expected_prev[0] !== last_end_port_exp[0]) ||
			on_first_change[2])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port end_port[0] :: @time = %t",  $realtime);
		$display ("     Expected value = %b", end_port_expected_prev);
		$display ("     Real value = %b", end_port_prev);
		nummismatches = nummismatches + 1;
		on_first_change[2] = 1'b0;
		last_end_port_exp[0] = end_port_expected_prev[0];
	end
	if (
		( end_port_expected_prev[1] !== 1'bx ) && ( end_port_prev[1] !== end_port_expected_prev[1] )
		&& ((end_port_expected_prev[1] !== last_end_port_exp[1]) ||
			on_first_change[2])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port end_port[1] :: @time = %t",  $realtime);
		$display ("     Expected value = %b", end_port_expected_prev);
		$display ("     Real value = %b", end_port_prev);
		nummismatches = nummismatches + 1;
		on_first_change[2] = 1'b0;
		last_end_port_exp[1] = end_port_expected_prev[1];
	end
	if (
		( end_port_expected_prev[2] !== 1'bx ) && ( end_port_prev[2] !== end_port_expected_prev[2] )
		&& ((end_port_expected_prev[2] !== last_end_port_exp[2]) ||
			on_first_change[2])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port end_port[2] :: @time = %t",  $realtime);
		$display ("     Expected value = %b", end_port_expected_prev);
		$display ("     Real value = %b", end_port_prev);
		nummismatches = nummismatches + 1;
		on_first_change[2] = 1'b0;
		last_end_port_exp[2] = end_port_expected_prev[2];
	end
	if (
		( flipA_expected_prev !== 1'bx ) && ( flipA_prev !== flipA_expected_prev )
		&& ((flipA_expected_prev !== last_flipA_exp) ||
			on_first_change[3])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port flipA :: @time = %t",  $realtime);
		$display ("     Expected value = %b", flipA_expected_prev);
		$display ("     Real value = %b", flipA_prev);
		nummismatches = nummismatches + 1;
		on_first_change[3] = 1'b0;
		last_flipA_exp = flipA_expected_prev;
	end
	if (
		( LOAD_CP_expected_prev !== 1'bx ) && ( LOAD_CP_prev !== LOAD_CP_expected_prev )
		&& ((LOAD_CP_expected_prev !== last_LOAD_CP_exp) ||
			on_first_change[5])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port LOAD_CP :: @time = %t",  $realtime);
		$display ("     Expected value = %b", LOAD_CP_expected_prev);
		$display ("     Real value = %b", LOAD_CP_prev);
		nummismatches = nummismatches + 1;
		on_first_change[5] = 1'b0;
		last_LOAD_CP_exp = LOAD_CP_expected_prev;
	end
	if (
		( progm0_expected_prev !== 1'bx ) && ( progm0_prev !== progm0_expected_prev )
		&& ((progm0_expected_prev !== last_progm0_exp) ||
			on_first_change[6])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port progm0 :: @time = %t",  $realtime);
		$display ("     Expected value = %b", progm0_expected_prev);
		$display ("     Real value = %b", progm0_prev);
		nummismatches = nummismatches + 1;
		on_first_change[6] = 1'b0;
		last_progm0_exp = progm0_expected_prev;
	end
	if (
		( progm1_expected_prev !== 1'bx ) && ( progm1_prev !== progm1_expected_prev )
		&& ((progm1_expected_prev !== last_progm1_exp) ||
			on_first_change[7])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port progm1 :: @time = %t",  $realtime);
		$display ("     Expected value = %b", progm1_expected_prev);
		$display ("     Real value = %b", progm1_prev);
		nummismatches = nummismatches + 1;
		on_first_change[7] = 1'b0;
		last_progm1_exp = progm1_expected_prev;
	end
	if (
		( progm2_expected_prev !== 1'bx ) && ( progm2_prev !== progm2_expected_prev )
		&& ((progm2_expected_prev !== last_progm2_exp) ||
			on_first_change[8])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port progm2 :: @time = %t",  $realtime);
		$display ("     Expected value = %b", progm2_expected_prev);
		$display ("     Real value = %b", progm2_prev);
		nummismatches = nummismatches + 1;
		on_first_change[8] = 1'b0;
		last_progm2_exp = progm2_expected_prev;
	end

	trigger <= ~trigger;
end
initial 

begin 
$timeformat(-12,3," ps",6);
#1000000;
if (nummismatches > 0)
	$display ("%d mismatched vectors : Simulation failed !",nummismatches);
else
	$display ("Simulation passed !");
$finish;
end 
endmodule

module circuito_vlg_vec_tst();
// constants                                           
// general purpose registers
reg clock;
reg K0;
reg K1;
reg K2;
reg RESET;
reg SEL0;
reg SEL1;
reg SEL2;
// wires                                               
wire [2:0] data_out;
wire [2:0] end_port;
wire flipA;
wire flipB;
wire LOAD_CP;
wire progm0;
wire progm1;
wire progm2;

wire sampler;                             

// assign statements (if any)                          
circuito i1 (
// port map - connection between master ports and signals/registers   
	.clock(clock),
	.data_out(data_out),
	.end_port(end_port),
	.flipA(flipA),
	.flipB(flipB),
	.K0(K0),
	.K1(K1),
	.K2(K2),
	.LOAD_CP(LOAD_CP),
	.progm0(progm0),
	.progm1(progm1),
	.progm2(progm2),
	.RESET(RESET),
	.SEL0(SEL0),
	.SEL1(SEL1),
	.SEL2(SEL2)
);

// clock
always
begin
	clock = 1'b0;
	clock = #25000 1'b1;
	#25000;
end 

// RESET
initial
begin
	RESET = 1'b0;
end 

// SEL2
initial
begin
	SEL2 = 1'b0;
end 

// SEL1
initial
begin
	SEL1 = 1'b0;
end 

// SEL0
initial
begin
	SEL0 = 1'b0;
end 

// K2
initial
begin
	K2 = 1'b0;
end 

// K1
initial
begin
	K1 = 1'b1;
end 

// K0
initial
begin
	K0 = 1'b0;
end 

circuito_vlg_sample_tst tb_sample (
	.clock(clock),
	.K0(K0),
	.K1(K1),
	.K2(K2),
	.RESET(RESET),
	.SEL0(SEL0),
	.SEL1(SEL1),
	.SEL2(SEL2),
	.sampler_tx(sampler)
);

circuito_vlg_check_tst tb_out(
	.data_out(data_out),
	.end_port(end_port),
	.flipA(flipA),
	.flipB(flipB),
	.LOAD_CP(LOAD_CP),
	.progm0(progm0),
	.progm1(progm1),
	.progm2(progm2),
	.sampler_rx(sampler)
);
endmodule

