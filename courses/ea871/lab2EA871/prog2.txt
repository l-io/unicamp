/*
 * Leonardo Rodrigues Marques - 178610	
 * Monica Aoki Faria - 156787
 */
// Roteiro 2 - Programa 2b - EA871-2S2017 - Le botoes de pressao da placa Shield

#include "derivative.h" /* include peripheral declarations */
#define SET_BIT(reg, idx)	reg = (reg | (1 << idx))	// Macro que seta o bit idx do registrador reg

/* Inicializa os GPIOs */
void init_GPIO(void) {
	
	/*Configuração dos botões*/
	SET_BIT(SIM_SCGC5, 9); 		// Habilita clock do PORTA
	
	PORTA_PCR4 &= 0xFFFFF8FF;	// Configura MUX para PTA4, PTA5, PTA12 aparecerem nos pinos
	SET_BIT(PORTA_PCR4, 8);
	PORTA_PCR5 &= 0xFFFFF8FF;
	SET_BIT(PORTA_PCR5, 8);
	PORTA_PCR12 &= 0xFFFFF8FF;
	SET_BIT(PORTA_PCR12, 8);

	GPIOA_PDDR = 0; 		// Configura todos bits do PORTA como entrada
	
	/*Configuração dos LEDs*/
	SET_BIT(SIM_SCGC5, 11);		// Habilita clock do PORTC (System Clock Gating Control)
			
		PORTC_PCR0 &= 0xFFFFF8FF;	// Configura MUX para PTC0-PTC7 e PTC10 aparecerem nos pinos
		SET_BIT(PORTC_PCR0, 8);		
		PORTC_PCR1 &= 0xFFFFF8FF;
		SET_BIT(PORTC_PCR1, 8);
		PORTC_PCR2 &= 0xFFFFF8FF;
		SET_BIT(PORTC_PCR2, 8);
		PORTC_PCR3 &= 0xFFFFF8FF;
		SET_BIT(PORTC_PCR3, 8);
		PORTC_PCR4 &= 0xFFFFF8FF;
		SET_BIT(PORTC_PCR4, 8);
		PORTC_PCR5 &= 0xFFFFF8FF;
		SET_BIT(PORTC_PCR5, 8);
		PORTC_PCR6 &= 0xFFFFF8FF;
		SET_BIT(PORTC_PCR6, 8);
		PORTC_PCR7 &= 0xFFFFF8FF;
		SET_BIT(PORTC_PCR7, 8);
		PORTC_PCR10 &= 0xFFFFF8FF;
		SET_BIT(PORTC_PCR10, 8);
		
		GPIOC_PDOR = 0;			// Garante nivel 0 em todas as saidas do PORTC
		GPIOC_PDDR = 0x000004FF;	// Configura bits 0-7 e 10 do PORTC como saidas
		GPIOC_PSOR = (1<<10);       // Habilita o LE (Latch Enable) do registrador dos LEDs vermelhos (74HC573)
		GPIOC_PCOR = (1<<10);		// Desabilita o LE (Latch Enable) do registrador dos LEDs vermelhos (74HC573)
}

int main(void) {
	
	init_GPIO();
	int b1=0;
	int b2=0;
	int b3=0;
	int flag1=0;
	int flag2=0;
	int flag3=0;
	
	uint16_t a, pta4, pta5, pta12, compare;
	
	for( ; ; ) {
		a = GPIOA_PDIR;       // Faz a leitura no PORTA (16 bits)
		pta4  = a & (1<<4);   
		pta5  = a & (1<<5);  
		pta12 = a & (1<<12);  
		
		if(pta5 == 0){
			flag2=1;
		}
		if(pta5!= 0 && flag2==1){
			b2 = 1;
			flag2=0;
		}	
		if(pta4 == 0 && pta12!=0){
			flag1=1;	
		}
		if(pta4!= 0 && flag1==1){
			b1 = 1;
			flag1=0;
		}	
		
		if(pta12 == 0 && pta4!=0){
			flag3=1;
		}
		if(pta12!= 0 && flag3==1){
			b3 = 1;
			flag3=0;
		}	
		
		
		
		//se s2 foi pressionado
		if(b2 == 1){
					
			compare = GPIOC_PDIR;
			compare = compare | 0xFFFFFFFE;
			
			//Se o ultimo bit for zero (ele estiver apagado)
			if(compare == 0xFFFE){
				GPIOC_PDOR = GPIOC_PDOR | 0x00000001;
				GPIOC_PSOR = (1<<10);
				GPIOC_PCOR = (1<<10);
				b2 = 0;
			}
			
			//Se o ultimo bit for 1 (ele estiver aceso)
			if(compare == 0xFFFF){
				GPIOC_PDOR = GPIOC_PDOR & 0xFFFFFFFE;
				GPIOC_PSOR = (1<<10);
				GPIOC_PCOR = (1<<10);
				b2 = 0;
			}
			
		}
		
		//se s1 foi pressionado
		if(b1==1 && b2!=1){
	
			GPIOC_PDOR = GPIOC_PDOR / 2;
			GPIOC_PSOR = (1<<10);
			GPIOC_PCOR = (1<<10);
			b1=0;
		}
		
		//se s3 foi pressionado
		if(b3==1 && b2!=1){
			
			GPIOC_PDOR = GPIOC_PDOR * 2;
			GPIOC_PSOR = (1<<10);
			GPIOC_PCOR = (1<<10);
			b3=0;
		}
		
		
	}
}
